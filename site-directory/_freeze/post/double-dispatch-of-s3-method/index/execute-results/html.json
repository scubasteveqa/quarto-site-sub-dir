{
  "hash": "8db0ee08524ecbc3c19c9c996f0761a1",
  "result": {
    "markdown": "---\ntitle: Double dispatch of S3 method\nauthor: Hiroaki Yutani\ndate: '2018-09-17'\nslug: double-dispatch-of-s3-method\ncategories:\n  - R internal\nformat:\n  html:\n    toc: true\n    toc-title: \"Contents\"\n    toc-location: left\n---\n\n\nWhen I tried to define an S3 class that contains multiple ggplot objects, I've faced the lessor-know mechanism of S3 method dispatch, *double dispatch*.\n\n## Problem\n\nTake a look at this example. `manyplot` class contains many plots, and displays them nicely when printted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nset.seed(100)\nd1 <- data.frame(x = 1:100, y = cumsum(runif(100)))\nd2 <- data.frame(x = 1:100, y = cumsum(runif(100)))\n\nplot_all <- function(...) {\n  l <- lapply(list(...), function(d) ggplot(d, aes(x, y)) + geom_line())\n  l <- unname(l)\n  class(l) <- \"manyplot\"\n  l\n}\n\nprint.manyplot <- function(x, ...) {\n  do.call(gridExtra::grid.arrange, x)\n}\n\np <- plot_all(d1, d2)\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/define-ggplot-1.png){width=672}\n:::\n:::\n\n\nSo far, so good.\n\nNext, I want to define `+` method, so that I can customize the plots just as I do with usual ggplot2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`+.manyplot` <- function(e1, e2) {\n  l <- lapply(e1, function(x) x + e2)\n  class(l) <- \"manyplot\"\n  l\n}\n```\n:::\n\n\nBut, this won't work...\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + theme_bw()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Incompatible methods (\"+.manyplot\", \"+.gg\") for \"+\"\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in p + theme_bw(): non-numeric argument to binary operator\n```\n:::\n:::\n\n\nWhat's this cryptic error? To understand what happened, we need to dive into the concept of S3's \"*double dispatch*\"\n\n## Double dispatch?\n\nUsually, S3's method dispatch depends only on the type of first argument. But, in cases of some infix operators like `+` and `*`, it uses both of their arguments; this is called *double dispatch*.\n\nWhy is this needed? According to [Advanced R](https://adv-r.hadley.nz/s3.html#double-dispatch):\n\n> This is necessary to preserve the commutative property of many operators, i.e. `a + b` should equal `b + a`.\n\nTo ensure this, if both `a` and `b` are S3 objects, the method chosen in `a + b` can be (c.f. [how `do_arith()` works with S3 objects](https://gist.github.com/yutannihilation/1c227c6d662c991cc2c66ca146de80ea#gistcomment-2708322)):\n\n| Does `a` have an S3 method? | Does `b` have an S3 method? | Are the methods same? | Whet method is chosen?                           |\n|:------------------|:------------------|:----------------|:----------------|\n| yes                         | yes                         | yes                   | `a`'s method or `b`'s method (they are the same) |\n| yes                         | yes                         | no                    | internal method                                  |\n| yes                         | no                          | \\-                    | `a`'s method                                     |\n| no                          | yes                         | \\-                    | `b`'s method                                     |\n| no                          | no                          | \\-                    | internal method                                  |\n\nHere's examples to show them clearly:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- function(x) structure(x, class = \"foo\")\n`+.foo` <- function(e1, e2) message(\"foo!\")\n\nbar <- function(x) structure(x, class = \"bar\")\n`+.bar` <- function(e1, e2) message(\"bar?\")\n\n# both have the same S3 method\nfoo(1) + foo(1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nfoo!\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\n# both have different S3 methods\nfoo(1) + bar(1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Incompatible methods (\"+.foo\", \"+.bar\") for \"+\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\nattr(,\"class\")\n[1] \"foo\"\n```\n:::\n\n```{.r .cell-code}\n# `a` has a method, and `b` doesn't\nfoo() + 1\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in structure(x, class = \"foo\"): argument \"x\" is missing, with no default\n```\n:::\n\n```{.r .cell-code}\n# `b` has a method, and `a` doesn't\n1 + foo()\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in structure(x, class = \"foo\"): argument \"x\" is missing, with no default\n```\n:::\n\n```{.r .cell-code}\n# both don't have methods\nrm(`+.foo`)\nfoo(1) + foo(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\nattr(,\"class\")\n[1] \"foo\"\n```\n:::\n:::\n\n\n## Explanation\n\nSo, now it's clear to our eyes what happened in the code below; they have different methods (`+.manyplot` and `+.gg`) so it falled back to internal method. But, because fundamentally they are `list`, the internal mechanism refused to add these two objects...\n\n\n::: {.cell}\n\n```{.r .cell-code}\np + theme_bw()\n```\n:::\n\n\n## How can I overcome this?\n\nHadley says [ggplot2 might eventually end up using the double-dispatch approach in vctrs](https://github.com/hadley/adv-r/issues/1195#issuecomment-421783467). So, we can wait for the last hope.\n\nIf you cannot wait, use S4. S4 can naturally do double dispatch because their method dispatch depends on the whole combination of types of the arguments.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}