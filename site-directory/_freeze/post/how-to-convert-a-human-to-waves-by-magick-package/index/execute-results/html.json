{
  "hash": "05e2f3d1a8ebb437a8a9f0eefcc78ebf",
  "result": {
    "markdown": "---\ntitle: How To Convert A Human To Waves By Magick Package\nauthor: Hiroaki Yutani\ndate: '2018-11-23'\ncategories:\n  - ggplot2\n  - magick\nformat:\n  html:\n    toc: true\n    toc-title: \"Contents\"\n    toc-location: left\nimage: ./images/preview.png\n---\n\n\nI saw this tweet about Mathematica last year, which naturally urged me to write the R version of this code.\n\n<blockquote class=\"twitter-tweet\">\n\n<p lang=\"ja\" dir=\"ltr\">\n\nMathematicaを使って，シュレーディンガーの顔をこのようなアニメーションにされたユーザの方がいらっしゃいます。コードも掲載されています。<a href=\"https://t.co/IDIzM8Xfy2\">https://t.co/IDIzM8Xfy2</a> <a href=\"https://t.co/ZTIbjtmXBm\">pic.twitter.com/ZTIbjtmXBm</a>\n\n</p>\n\n--- Wolfram Japan (@WolframJapan) <a href=\"https://twitter.com/WolframJapan/status/875407701676785664?ref_src=twsrc%5Etfw\">June 15, 2017</a>\n\n</blockquote>\n\n\n```{=html}\n<script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n```\n\nAt that time, I faild because I didn't know how to zoom images. But, now I know magick package. Let's try again...\n\n## Zoom images by magick\n\nWe can enlarge a image by either `image_resize()`, `image_scale()`, or `image_sample()`. I don't know about the details of the differences, but it seems `image_resize()` does better for my purpose.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magick)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to ImageMagick 6.9.12.3\nEnabled features: cairo, freetype, fftw, ghostscript, heic, lcms, pango, raw, rsvg, webp\nDisabled features: fontconfig, x11\n```\n:::\n\n```{.r .cell-code}\nrose <- image_convert(image_read(\"rose:\"), \"png\")\n\nroses <- c(\n    image_resize(rose, \"400x\"),\n    image_scale(rose, \"400x\"),\n    image_sample(rose, \"400x\")\n)\n\nimage_append(roses, stack = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=200}\n:::\n:::\n\n\nBut, zooming is not just about resizing; I want to focus on the center of the image as well. To do this, we can use `image_crop()`. But, it's our job to calculate the perper offset to centering the image (IIUC, there's no equivalent of `-gravity center` in magick package, right??).\n\nSuppose we want to zoom by 200%. First of all, extract the original width and height.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfo <- image_info(rose)\norig_width <- info$width\norig_height <- info$height\n```\n:::\n\n\nThen, let's calculate the offset; to center the image, the offset should be half of the diffrence between the original size and the size you want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwidth <- as.integer(orig_width * 2)\nheight <- as.integer(orig_height * 2)\n\noffset_x <- as.integer((width - orig_width) / 2)\noffset_y <- as.integer((height - orig_height) / 2)\n```\n:::\n\n\nNow we have enough information to crop the image. To provide these to Imagemagick, we need to learn a bit about [Geometry syntax](https://www.imagemagick.org/Magick++/Geometry.html). It's as simple as:\n\n    <width>x<height>{+-}<xoffset>{+-}<yoffset>\n\nWe can construct the geometries by `sprintf()` (use `%+d` instead of `%d` when we need explicit plus sign) as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(g_resize <- sprintf(\"%dx%d\", width, height))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"140x92\"\n```\n:::\n\n```{.r .cell-code}\n(g_crop <- sprintf(\"%dx%d%+d%+d\", orig_width, orig_height, offset_x, offset_y))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"70x46+35+23\"\n```\n:::\n:::\n\n\nNow we can zoom\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrose_zoomed <- rose %>%\n  image_resize(g_resize) %>% \n  image_crop(g_crop)\n\nimage_append(c(rose, rose_zoomed), stack = TRUE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=35}\n:::\n:::\n\n\n## Zoom animatedly\n\nNow that we know how to zoom, we can create a function to draw rose at the specified zoom level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzoom_rose <- function(zoom = 1) {\n  width <- as.integer(orig_width * zoom)\n  height <- as.integer(orig_height * zoom)\n  \n  offset_x <- as.integer((width - orig_width) / 2)\n  offset_y <- as.integer((height - orig_height) / 2)\n  \n  g_resize <- sprintf(\"%dx%d\", width, height)\n  g_crop <- sprintf(\"%dx%d%+d%+d\", orig_width, orig_height, offset_x, offset_y)\n\n  rose %>%\n    image_resize(g_resize) %>% \n    image_crop(g_crop)\n}\n\nzoom_rose(1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=35}\n:::\n\n```{.r .cell-code}\nzoom_rose(2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-2.png){width=35}\n:::\n:::\n\n\nThe function can be applied to the vector of zoom levels by `lapply()`. Note that, to make the zoom speed looks constant, we need to power the steps.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsteps <- 100\nzooms <- 1 + 9 * (0:steps / steps)^2\nimgs <- lapply(zooms, zoom_rose)\n```\n:::\n\n\nThe list of images can be combined by `image_join()` and then can be converted to an animation by `image_animate()`\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_394467fef750c6a6f6f36aaf771eac75'}\n\n```{.r .cell-code}\nimgs %>%\n  image_join() %>%\n  image_animate(fps = 50)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.gif)\n:::\n:::\n\n\n## Result\n\nAparently, there are a lot of things to explain (expecially about involute of a circle), but it would be a bit too long... Let's jump to the final version of my code and the result :P\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_3477a0d24f58c207c2319e3a0a5e2b6c'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(tibble)\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# the speed of involute increases uniformly; in order to make the lengths between\n# steps equal, we need to calculate the square root\nresolution_of_involute <- 10000L\nt <- sqrt(seq(0, resolution_of_involute) / resolution_of_involute)\n\ncoil_turns <- 17L\nmax_r <- coil_turns * 2 * pi\n\n# waviness of the coil\nwave_frequency <- 100\nwave_height_base <- pi\n\n# download and read the image\nimg_file <- tempfile(fileext = \".png\")\ndownload.file(\"https://hoxo-m.com/img/team/makiyama.png\", destfile = img_file, mode = \"wb\")\nimg_orig <- image_read(img_file)\n\n# convert to grayscale\nimg_bw <- img_orig %>% \n  image_convert(type = \"grayscale\") %>%\n  image_modulate(brightness = 160) %>% \n  image_contrast(10)\n\n# the width and height of the output\nw <- 320\nh <- 320\n\n# the width and height of the original image\ninfo <- image_info(img_bw)\nw_orig <- info$width\nh_orig <- info$height\n\n# the width and height of the zoomed image\nscale <- 30L\nw_big <- w_orig * scale\nh_big <- h_orig * scale\n\n# zoom image\nimg_bw_big <- image_resize(img_bw, sprintf(\"%dx%d\", w_big, h_big))\n\n# place the small image on the center of the big image\nimg <- image_composite(img_bw_big, img_bw,\n                       offset = sprintf(\"%+d%+d\",\n                                        as.integer((w_big - w_orig) / 2),\n                                        as.integer((h_big - h_orig) / 2)))\n\ndraw_hoxom <- function(rotation = 0, zoom = 1) {\n  # unwavy involute\n  d <- tibble(\n    radius = 2 * pi * t * coil_turns,\n    phi = radius - rotation,\n    .x = cos(phi) + radius * sin(phi),\n    .y = sin(phi) - radius * cos(phi)\n  )\n\n  # crop and resize the image at the specified zoom level\n  g <- sprintf(\"%dx%d%+d%+d\",\n               as.integer(w_big / zoom),\n               as.integer(h_big / zoom),\n               as.integer((w_big - w_big / zoom) / 2),\n               as.integer((h_big - h_big / zoom) / 2))\n  \n  blackness <- img %>%\n    image_crop(g) %>%\n    image_resize(sprintf(\"%dx%d\", w, h)) %>%\n    image_data(\"gray\")\n\n  # calculate which pixel each point falls in\n  x_idx <- as.integer(scales::rescale(d$.x, from = c(-max_r, max_r), to = c(1L, dim(blackness)[2])))\n  y_idx <- as.integer(scales::rescale(d$.y, from = c(-max_r, max_r), to = c(dim(blackness)[3], 1L)))\n  \n  # determine the wave height based on the blackness\n  wave_height <- (255 - as.numeric(blackness[cbind(1, x_idx, y_idx)])) / 256 * wave_height_base\n\n  # wavy involute  \n  d_wavy <- d %>% \n    mutate(\n      x = .x + wave_height * sin(phi * wave_frequency) * sin(phi),\n      y = .y - wave_height * sin(phi * wave_frequency) * cos(phi)\n    )\n  \n  p <- ggplot(d_wavy) +\n    geom_path(aes(x, y)) +\n    theme_minimal() +\n    coord_equal(\n      # 0.85 is for zoom\n      xlim = c(-max_r, max_r) * 0.85,\n      ylim = c(-max_r, max_r) * 0.85\n    ) +\n    theme_void()\n  \n  print(p)\n}\n\n\nimgs <- image_graph(w, h, res = 72)\n\nsteps <- 100\nfor (i in seq_len(steps)) {\n  draw_hoxom(2 * pi * i / steps, 1 + (scale - 1) / steps^2 * i^2)\n}\n\ndev.off()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npng \n  2 \n```\n:::\n\n```{.r .cell-code}\nimage_animate(imgs, fps = 50)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.gif)\n:::\n:::\n\n\nI'm grad I've finally proven that I can live without Mathematica!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}