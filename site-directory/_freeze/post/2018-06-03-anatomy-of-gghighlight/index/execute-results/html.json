{
  "hash": "16b104e508bcf16b9912b903b1fbf869",
  "result": {
    "markdown": "---\ntitle: \"Anatomy of gghighlight\"\nauthor: Hiroaki Yutani\ndate: \"2018-06-03\"\ncategories: [\"gghighlight\", \"ggplot2\"]\n---\n\n\n\n\nI'm overhauling my [gghighlight](https://github.com/yutannihilation/gghighlight) package toward the upcoming release of ggplot2 2.3.0. I think I will introduce about the new `gghighlight()` soon, but before that, I want to write out the ideas behind gghighlight.\n\nNote that what I'll write here contains few new things, as the basic idea is already covered by this great post:\n\n-   [Plotting background data for groups with ggplot2](https://drsimonj.svbtle.com/plotting-background-data-for-groups-with-ggplot2)\n\nMy post is mainly for organizing my thought, yet I hope someone find this useful :)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tweak for plotting\nknit_print.ggplot <- function(x, ...) {\n  x <- x  +\n    theme_minimal() +\n    scale_x_continuous(expand = expand_scale(mult = 0.5)) +\n    scale_y_continuous(expand = expand_scale(mult = 0.2))\n  ggplot2:::print.ggplot(x, ...)\n}\n```\n:::\n\n\n## Data\n\nSuppose we have this data:\n\n\n::: {.cell}\n::: {.cell-output-display}\n|  x|  y|type | value|\n|--:|--:|:----|-----:|\n|  3|  3|a    |     0|\n|  8|  3|a    |     1|\n| 13|  3|a    |     0|\n|  2|  2|b    |     0|\n|  7|  2|b    |    10|\n| 12|  2|b    |    10|\n|  1|  1|c    |    10|\n|  6|  1|c    |    20|\n| 11|  1|c    |     0|\n:::\n:::\n\n\n## Simple plot\n\nIf we plot the data very simply, the code would be like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nggplot(d, aes(x, y, colour = type)) +\n  geom_point(size = 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `expand_scale()` was deprecated in ggplot2 3.3.0.\nPlease use `expansion()` instead.\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot1-1.png){width=672}\n:::\n:::\n\n\n## Highlighted plot\n\nNow, what if we want to highlight only the points of records whose `type` are `\"b\"`?\n\nWe need two layers:\n\n1.  unhighlighted layer\n2.  highlighted layer\n\n### Create an unhighlighted layer\n\nAn unhighlighted layer is the colorless version of the above points with the same data. To create this, we can simply remove `colour` from `aes()` and specify a static colour `\"grey\"`. I call this operation as *bleach*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbleached_layer <- geom_point(data = d, aes(x, y),\n                             size = 10, colour = \"grey\")\n```\n:::\n\n\nIf we plot this, the result would be below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  bleached_layer\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unhighlighted-layer-plot-1.png){width=672}\n:::\n:::\n\n\n### Create a highlighted layer\n\nA highlighted layer is the fewer-data version of the above points with (not necessarily the same) colors. To create this, we need some data manipulation. Let's filter the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_sieved <- filter(d, type == \"b\")\n```\n:::\n\n\nThen the layer we want can be created like below. I call this operation as *sieve* (*filter* might be a better word, but I wanted to choose another word than dplyr's verbs to avoid confusion).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsieved_layer <- geom_point(data = d_sieved, aes(x, y, colour = type),\n                           size = 10)\n```\n:::\n\n\nIf we plot this, the result would be below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  sieved_layer\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/highligted-layer-plot-1.png){width=672}\n:::\n:::\n\n\n### Join the two layers\n\nNow we can draw the highlighted version of the plot as below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  bleached_layer +\n  sieved_layer\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/highlighted-plot-1.png){width=672}\n:::\n:::\n\n\n## \"by point\" vs \"by group\"\n\nSo far, so good. Then, let's consider a bit about the case when the geom is not point, but line.\n\nWhile points can be plotted one by one, lines cannot be drawn without the relationship between points. For example, haven't you experienced an unexpected zigzag line?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x, y)) +\n  geom_line(size = 3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nsize aesthetic has been deprecated for use with lines as of ggplot2 3.4.0\nâ„¹ Please use linewidth aesthetic instead\nThis message is displayed once every 8 hours.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-strange-1.png){width=672}\n:::\n:::\n\n\nLines need `group` variable, which indicates the series of data points.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x, y, group = type)) +\n  geom_line(size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-ok-1.png){width=672}\n:::\n:::\n\n\nNote that `group` doesn't need to be declared explicitly, as ggplot2 infers the groups from the specified variables. More precisely, it calculates group IDs based on the combination of discrete variables [here](https://github.com/tidyverse/ggplot2/blob/8778b48b37d8b7e41c0f4f213031fb47810e70aa/R/grouping.r#L11-L28). So, usually, specifying a discrete variable on `colour` or `fill` is enough.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x, y, colour = type)) +\n  geom_line(size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-ok-colour-1.png){width=672}\n:::\n:::\n\n\nAnyway, lines need groups. Accordingly, we need to consider the group when we *sieve* the data. Otherwise, the lines will be incomplete as this example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# data whose values are >=10\nd_sieved2 <- filter(d, value >= 10)\n\nggplot() +\n  geom_line(data = d, aes(x, y, group = type), size = 3, colour = \"grey\") +\n  geom_line(data = d_sieved2, aes(x, y, colour = type), size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-ungrouped-sieve-1.png){width=672}\n:::\n:::\n\n\nSo, the correct way of doing this is to use `group_by()` and some aggregate functions like `max()` so that the calculations are done by group.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# data series whose max values are >=10\nd_sieved3 <- d %>%\n  group_by(type) %>% \n  filter(max(value) >= 10)\n\nggplot() +\n  geom_line(data = d, aes(x, y, group = type), size = 3, colour = \"grey\") +\n  geom_line(data = d_sieved3, aes(x, y, colour = type), size = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-grouped-sieve-1.png){width=672}\n:::\n:::\n\n\n## Prevent unhighlighted layer from facetted\n\nNext topic is facetting. Let's naively facet the plot above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot() +\n  geom_line(data = d, aes(x, y, group = type), size = 3, colour = \"grey\") +\n  geom_line(data = d_sieved3, aes(x, y, colour = type), size = 3) +\n  facet_wrap(~ type)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-grouped-sieve-facet-1.png){width=672}\n:::\n:::\n\n\nHmm..., unhighlighted lines are facetted. But, maybe we want the grey ones exists in all of the panels.\n\n`facet_*()` facets all layers if the data contains the specified variable, in this case `type`. In other words, if the layer's data doesn't have the variable, it won't get facetted. Let's rename it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd_bleached <- d\nnames(d_bleached)[3] <- \"GROUP\"\n\nggplot() +\n  geom_line(data = d_bleached, aes(x, y, group = GROUP), size = 3, colour = \"grey\") +\n  geom_line(data = d_sieved3, aes(x, y, colour = type), size = 3) +\n  facet_wrap(~ type)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/lines-grouped-sieve-facet2-1.png){width=672}\n:::\n:::\n\n\nYou may notice about one more good thing; the panel for `\"a\"` disappeared. This is because now `d_sieved3` is the only data that contains `type` and it has only records of `\"b\"` and `\"c\"`.\n\n## Some spoilers\n\nThe next version of gghighlight will do the above things almost automatically. All you have to do is just adding `gghighlight()`.\n\n\n::: {.cell preview='true'}\n\n```{.r .cell-code}\nlibrary(gghighlight)\n\nggplot(d, aes(x, y, colour = type)) +\n  geom_point(size = 10) +\n  gghighlight(type == \"b\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Tried to calculate with group_by(), but the calculation failed.\nFalling back to ungrouped filter operation...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nlabel_key: type\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/gghighlight1-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(d, aes(x, y, colour = type)) +\n  geom_line(size = 3) +\n  gghighlight(max(value) >= 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nlabel_key: type\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/gghighlight2-1.png){width=672}\n:::\n:::\n\n\nStay tuned!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}