{
  "hash": "79f2b4e1ea29015dd8f389f0c61232b7",
  "result": {
    "markdown": "---\ntitle: \"Writing A Configure Script For An R Package Using Rust\"\ndescription: |\n  `configure.win` and `configure`\nauthor:\n  - name: Hiroaki Yutani\n    url: {}\ndate: 09-21-2021\ncategories:\n  - Rust\n  - extendr\noutput:\n  distill::distill_article:\n    toc: true\n    toc_depth: 2\n    self_contained: false\ncreative_commons: CC BY\neditor_options: \n  markdown: \n    wrap: 72\n---\n\n\nI've been struggling with `configure.win` for several days. I think I've done,\nbut it seems I've come too far from [the last post](https://yutani.rbind.io/post/2021-08-01-unofficial-introduction-to-extendr-appendix-i-setup-github-actions-ci-and-more/#provide-precompiled-binaries-for-windows). So, let me try to explain what a `configure.win` (or\n`configure`) would look like.\n\nLet's start with this `Makevars.win`, basically the same one on the last blog post.\n\n``` makefile\nCRATE = string2path\nBASE_TAG = windows_20210801-3\n\nTARGET = $(subst 64,x86_64,$(subst 32,i686,$(WIN)))-pc-windows-gnu\nLIBDIR = ./rust/target/$(TARGET)/release\nSTATLIB = $(LIBDIR)/libstring2path.a\nPKG_LIBS = -L$(LIBDIR) -lstring2path -lws2_32 -ladvapi32 -luserenv\n\n# c.f. https://stackoverflow.com/a/34756868\nCARGO_EXISTS := $(shell cargo --version 2> /dev/null)\n\nall: C_clean\n\n$(SHLIB): $(STATLIB)\n\n$(STATLIB):\nifdef CARGO_EXISTS\n\tcargo build --target=$(TARGET) --lib --release --manifest-path=./rust/Cargo.toml\nelse\n\tmkdir -p $(LIBDIR)\n\tcurl -L -o $(STATLIB) https://github.com/yutannihilation/$(CRATE)/releases/download/$(BASE_TAG)/$(TARGET)-lib$(CRATE).a\nendif\n\nC_clean:\n\trm -Rf $(SHLIB) $(STATLIB) $(OBJECTS)\n\nclean:\n\trm -Rf $(SHLIB) $(STATLIB) $(OBJECTS) rust/target\n```\n\n## Tweak `Makevars.win`\n\nBefore talking about configure scripts, I have to write a bit about `Makevars.win`\n(and `Makevars`) because it has something to be fixed.\n\n### Set `CARGO_HOME`\n\nCan you see what part is wrong in the above `Makevars.win`? After the first CRAN\nsubmission of this package, I got this reply:\n\n> Checking this creates ~/.cargo sized 82MB, in violation of the CRAN Policy.\n> Please fix as necessary and resubmit.\n\n[The CRAN Policy](https://cran.r-project.org/web/packages/policies.html) says:\n\n> - Packages should not write in the user’s home filespace (including clipboards), \n>   nor anywhere else on the file system apart from the R session’s temporary directory \n>   (or during installation in the location pointed to by TMPDIR: and such usage should be cleaned up).\n\nBy default, `cargo` uses `~/.cargo` for caching various things like the crates.io \nindex and the dependency crates. Apparently, this is not allowed. To avoid this,\nwe can set `CARGO_HOME` to the package's local directory, like [gifski package\ndoes](https://github.com/r-rust/gifski/blob/6b86cc6b60abbc2294db821f27cae37413df70c2/src/Makevars#L10).\n\n``` makefile\nexport CARGO_HOME=$(PWD)/.cargo\n```\n\nAlternatively, we can set this on the head of the line of `cargo build` directly.\n\n``` makefile\nCARGO_HOME=$(PWD)/.cargo\n\n...snip...\n\n  CARGO_HOME=$(PWD)/.cargo cargo build --target=$(TARGET) --lib --release --manifest-path=./rust/Cargo.toml\n```\n\nIn addition to this, as it \"should be cleaned up,\" we also need to add these two lines\nafter `cargo build`:\n\n``` makefile\n\trm -Rf $(CARGO_HOME)\n\trm -Rf $(LIBDIR)/build\n```\n\nBut, this is a bit painful in terms of development. Why do I need to compile\nit always from scratch even on my local??\n\n### `NOT_CRAN` environmental variable\n\nFortunately, devtools utilities provide `NOT_CRAN` envvar to distinguish CRAN\nand other environment. So, maybe we can determine whether to set `CARGO_HOME`,\ndepending on `NON_CRAN`. It would be:\n\n``` makefile\n# An envvar cannot be referred to as $(NOT_CRAN)\nNOT_CRAN_ENVVAR = ${NOT_CRAN}\n\n$(STATLIB):\nifeq ($(NOT_CRAN_ENVVAR),\"true\")\n  cargo build --target=$(TARGET) --lib --release --manifest-path=./rust/Cargo.toml\nelse\n  CARGO_HOME=$(PWD)/.cargo cargo build --target=$(TARGET) --lib --release --manifest-path=./rust/Cargo.toml\n\trm -Rf $(CARGO_HOME)\n\trm -Rf $(LIBDIR)/build\nendif\n```\n\n### Set `PATH`\n\nOne more thing my `Makevars` (not `Makevars.win` this time) couldn't covered\nwas the case when `cargo` is on `PATH` but `rustc` is not. It seems gifski package\nhandles this by including `$(HOME)/.cargo/bin` in `PATH` ([Makevars](https://github.com/r-rust/gifski/blob/6b86cc6b60abbc2294db821f27cae37413df70c2/src/Makevars#L13)).\n\nI think sourcing `\"$(HOME)/.cargo/env\"` should also work (this actually just sets\n`PATH`), so I'll try this next time. Note that `source` is not available on dash,\nso use `.` for this.\n\n``` sh\n. \"$(HOME)/.cargo/env\" && cargo build ...\n```\n\nOkay, done. Let's move onto configure scripts.\n\n## What is a configure script?\n\nA configure script is often used for configuring `Makefile` or `Makevars`,\ndepending on the user's setup.\n\n[Writing R Extensions](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html#Configure-and-cleanup) says:\n\n> If your package needs some system-dependent configuration before installation\n> you can include an executable (Bourne shell script `configure` in your package\n> which (if present) is executed by `R CMD INSTALL` before any other action is \n> performed. \n\n`configure` is executed on UNIX-alikes, and Windows uses a different file `configure.win`[^ucrt].\nActually, I got this request from CRAN:\n\n[^ucrt]: There's also [`configure.ucrt`](https://stat.ethz.ch/pipermail/r-devel/2021-September/081093.html), but you can forget this for now.\n\n> By the way, ideally string2path would use configure to test for cargo\n\nSo far, I used `Makevars.win` for testing the existence of `cargo`, but it seems\nconfigure scripts are the better place for this. Moreover, I do want to check the\ncargo functionality more precisely, for example,\n\n* if the Rust version is not too old to support (\"MSRV\")\n* (Windows only) if the Rust installation has the required toolchain, `stable-msvc`\n* (Windows only) if the Rust installation has the required targets, `x86_64-pc-windows-gnu` and `i686-pc-windows-gnu`\n\nbut `Makevars.win` is a bit too narrow to write a complex shell script.\n\n## `Biarch: true`\n\nIf we use `configure.win`, we have to add the following line to `DESCRIPTION`.\n\n```\nBiarch: true\n```\n\nOtherwise, the 32-bit version won't get built for unknown reason and it makes CRAN angry.\nThis behaviour is found on [R for Windows FAQ](https://cran.r-project.org/bin/windows/base/rw-FAQ.html#How-do-I-build-my-package-for-both-32_002d-and-64_002dbit-R_003f),\nbut it doesn't explain what we should do. I found this on the following post on\nRStudio Community.\n\n* <https://community.rstudio.com/t/configure-win-and-cran-submission/24684/4>\n\n## Check `cargo`\n\n### Check `cargo` is installed\n\nThis is simple.\n\n``` sh\ncargo version >/dev/null 2>&1\nif [ $? -ne 0 ]; then\n  echo \"cargo command is not available\"\n  exit 1\nfi\n```\n\nNote that we don't want to exit here, because the absence of `cargo` isn't the\nend of the world; there might be a precompiled binary for the platform. But,\nlet's tweak it later.\n\n### Check if the Rust version is not too old to support\n\nThis isn't always necessary, but we might want to reject the older Rust in the\ncase when we use some feature that is available after the specific version of Rust.\nYou know, comparing versions is tricky. But, this can be archived by `sort`\ncommand with `-V` option and `-C` option (c.f. [SO answer](https://unix.stackexchange.com/a/567537)).\n`-V` means version sort. `-C` means checking if the input is already sorted,\nand errors when it's not. In summary, the implementation is the following:\n\n```sh\n# c.f. https://github.com/ron-rs/ron/issues/256#issuecomment-657999081\nMIN_RUST_VERSION=\"1.41.0\"\n\nRUST_VERSION=\"`cargo --version | cut -d' ' -f2`\"\nif ! printf '%s\\n' \"${MIN_RUST_VERSION}\" \"${RUST_VERSION}\" | sort -C -V; then\n  echo \"The installed version of cargo (${RUST_VERSION}) is older than the requirement (${MIN_RUST_VERSION})\"\n  exit 1\nfi\n```\n\n(Btw, did you know we cannot use `$(expr)` notation in `configure` because\nthis syntax isn't available on Solaris? We need to use `` `expr` `` instead)\n\n### Check if the Rust installation has the required toolchain and targets (Windows only)\n\nOn Windows, extendr provides support only the specified set of toolchain and\ntarget. So, we need to check it.\n\nChecking toolchain is simple. Use `+` to specify the toolchain.\n\n``` sh\nEXPECTED_TOOLCHAIN=\"stable-msvc\"\n\ncargo \"+${EXPECTED_TOOLCHAIN}\" version >/dev/null 2>&1\nif [ $? -ne 0 ]; then\n  echo \"${EXPECTED_TOOLCHAIN} toolchain is not installed\"\n  exit 1\nfi\n```\n\nInstalled targets can be listed by `rustup target list --installed`.\nSo, the check would be like\n\n``` sh\nEXPECTED_TARGET=\"x86_64-pc-windows-gnu\"\n\nif ! rustup target list --installed | grep -q \"${EXPECTED_TARGET}\"; then\n  echo \"target ${EXPECTED_TARGET} is not installed\"\n  exit 1\nfi\n```\n\nOne thing tricky here is that, unlike `Makevars.win`, `configure.win` is\nexecuted only once, not per architecture. So, we need to manually enumerate\nboth 64-bit and 32-bit.\n\nOne more tricky thing at the time of writing this is..., you might not notice,\nthe 32-bit version no longer exists in R-devel, which is supposed to be\nreleased as R 4.2! So, we want to check 32-bit only when there's 32-bit. How?\nI couldn't come up with some nice way, but it seems check on `${R_HOME}/bin/i386/`\nworks:\n\n``` sh\ncheck_cargo_target() {\n  EXPECTED_TARGET=\"$1\"\n  \n  if ! rustup target list --installed | grep -q \"${EXPECTED_TARGET}\"; then\n    echo \"target ${EXPECTED_TARGET} is not installed\"\n    exit 1\n  fi\n}\n\ncheck_cargo_target x86_64-pc-windows-gnu\n\nif [ -d \"${R_HOME}/bin/i386/\" ]; then\n  check_cargo_target i686-pc-windows-gnu\nfi\n```\n\n## But what can we do?\n\nNow we can check the `cargo` installation. But, if the check fails, what should\nwe do? Actually, on CRAN, Windows and macOS machines don't have Rust installed.\n\nThere are two options.\n\n1. Install `cargo` into the temporary directory\n2. Download the precompiled binaries (which means you have to serve the binaries on somewhere beforehand).\n\nFor example, the gifski package uses option 1 for macOS and option 2 for Windows.\nMy string2path package now uses option 2 both for macOS and for Windows.\n\n## Install `cargo` on the fly\n\n[The implementation for macOS](https://github.com/r-rust/gifski/blob/6b86cc6b60abbc2294db821f27cae37413df70c2/configure#L11-L12) is below.\nThe actual process is written in the downloaded script, but what it does is basically downloading `cargo`.\n\n``` sh\n# Try local version on MacOS, otherwise error\n[ `uname` = \"Darwin\" ] && curl \"https://autobrew.github.io/scripts/rust\" -sSf | sh && exit 0\n```\n\nI don't write much about this this time, but [cargo package](https://cran.r-project.org/package=cargo) should also be useful for this strategy.\n\n## Download the precompiled binaries\n\nThis is what was done in `Makevars.win`.\n\n```\n$(STATLIB):\nifdef CARGO_EXISTS\n\tcargo build --target=$(TARGET) --lib --release --manifest-path=./rust/Cargo.toml\nelse\n\tmkdir -p $(LIBDIR)\n\tcurl -L -o $(STATLIB) https://github.com/yutannihilation/$(CRATE)/releases/download/$(BASE_TAG)/$(TARGET)-lib$(CRATE).a\nendif\n```\n\nTo move this to `configure` and `configure.win`. There are several things to consider.\nFor example:\n\n* As this downloads the binary before `$(STATLIB)` is executed, we need some tweak to ensure it's not removed by `C_clean`\n* (Windows only) unlike `Makevars.win` is executed per arch, `configure.win` is executed only once\n\nWhat's more, I want to make one addition:\n\n* Verify the checksums\n\nSome might have wondered if it's safe to download an arbitrary binary from GitHub.\nFirst of all, I'd argue it's safe. To say the least, essentially, it's no unsafer\nthan downloading a cargo binary itself, (or than \"`curl URL | sh`\").\nIf it's downloaded over HTTPS, the data hardly gets compromised as long as their\nservers are not compromised. I believe GitHub servers and Rust servers are both\nvery secure.\n\nThat said, we can improve the security further by \"pinning\" the binary. So, I\nrecommend verifying the checksum when downloading a binary. For example, [the \nstringi package does this](https://github.com/gagolews/stringi/blob/60ac05ecbc71aa49dd1f8137453b0f466728c787/R/install.R#L120).\n\n### `Makevars.in` and `Makevars.win.in`\n\nRemember `Makevars.win` has these lines (`$(STATLIB)` is the artifact of the Rust code):\n\n``` makefile\nall: C_clean\n```\n```makefile\nC_clean:\n\trm -Rf $(SHLIB) $(STATLIB) $(OBJECTS)\n```\n\nRemoving `$(STATLIB)` is needed to invoke `cargo build` in the case when\n`cargo` is installed. Otherwise, `$(STATLIB)` keeps existing, which means\nthat target is never executed.\n\nOn the other hand, we don't want to execute `cargo build` if there's no `cargo`.\nSo, in this case, we need to prevent the downloaded binary from getting removed.\n\nIn order to change the logic like this, we can use `Makevars.in` and `Makevars.win.in`\nas a template to generate `Makevars` and `Makevars.win` respectively. Generating\nthese files can be done in `configure` and `configure.win`. For example,\n\n`Makevars.in`:\n```makefile\nC_clean:\n\trm -Rf $(SHLIB) $(OBJECTS) @CLEAN_EXTRA@\n```\n\n`configure`:\n```makefile\n# cargo installed\nsed -e 's|@CLEAN_EXTRA@|$(STATLIB)|' src/Makevars.in > src/Makevars\n\n# no cargo\nsed -e 's|@CLEAN_EXTRA@||' src/Makevars.in > src/Makevars\n```\n\nIf we generate `Makevars` and `Makevars.win` in configure scripts, we also need\nto clean up these by the `cleanup` script (this is required by Writing R Extensions).\n\n``` sh\nrm -f src/Makevars src/Makevars.win\n```\n\nOf course, don't forget to add `src/Makevars` and `src/Makevars.win` to `.gitignore`.\n\n(Probably, we can generate more sophisticated `Makevars`, but this time I used\nonly this one replacement.)\n\n### Verify the checksums\n\nTo verify the checksum, we can use `sha256sum` on platforms other than macOS,\nand `shasum -a 256` on macOS. For the example of macOS:\n\n``` sh\nSHA256SUM_EXPECTED=be65f074cb7ae50e5784e7650f48579fff35f30ff663d1c01eabdc9f35c1f87c\n\n# Verify the checksum\nSHA256SUM_ACTUAL=`shasum -a 256 \"${DST}\" | cut -d' ' -f1`\nif [ -z \"${SHA256SUM_ACTUAL}\" ]; then\n  echo \"Failed to get the checksum\"\n  exit 1\nfi\n\nif [ \"${SHA256SUM_ACTUAL}\" != \"${SHA256SUM_EXPECTED}\" ]; then\n  echo \"Checksum mismatch for the pre-compiled binary\"\n  exit 1\nfi\n```\n\n\n## [MOST IMPORTANT!] Ask CRAN maintainers to exclude Solaris\n\nOh, sorry, I forgot to enumerate the most important option!\n\n0. Give up\n\nBecause 32-bit Solaris is not a supported platform by Rust, there's no option\nother than giving up. I wrote this on cran-comment and it seems this was accepted:\n\n> I would like to request to exclude Solaris from the build targets because Solaris is not a supported platform by Rust. This should be in line with the treatments of other CRAN packages that use Rust; gifski, baseflow, and salso are not built on Solaris. I'm sorry that I didn't write this in the first submission.\n\nBe sure to add some comment like this when you submit an R package with Rust to CRAN!\n\n## Example\n\nFor a real example, please refer to [string2path](https://github.com/yutannihilation/string2path), though your mileage may vary.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}